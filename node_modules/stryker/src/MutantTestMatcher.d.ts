import { RunResult } from 'stryker-api/test_runner';
import { StrykerOptions, File } from 'stryker-api/core';
import { Mutant } from 'stryker-api/mutant';
import TestableMutant from './TestableMutant';
import StrictReporter from './reporters/StrictReporter';
import { CoverageMapsByFile } from './transpiler/CoverageInstrumenterTranspiler';
import SourceMapper from './transpiler/SourceMapper';
export default class MutantTestMatcher {
    private mutants;
    private files;
    private initialRunResult;
    private sourceMapper;
    private coveragePerFile;
    private options;
    private reporter;
    private readonly log;
    constructor(mutants: Mutant[], files: File[], initialRunResult: RunResult, sourceMapper: SourceMapper, coveragePerFile: CoverageMapsByFile, options: StrykerOptions, reporter: StrictReporter);
    private readonly baseline;
    matchWithMutants(): TestableMutant[];
    enrichWithCoveredTests(testableMutant: TestableMutant): void;
    private isCoveredByBaseline(fileName, statementIndex);
    private isCoveredByTest(testId, fileName, statementIndex);
    private isCoveredByCoverageCollection(coveredFile, statementIndex);
    private createTestableMutants();
    /**
     * Map the Mutant object on the MatchMutant Object.
     * @param testableMutant The mutant.
     * @returns The MatchedMutant
     */
    private mapMutantOnMatchedMutant(testableMutant);
    private findMatchingStatement(location, fileCoverage);
    /**
     * Finds the smallest statement that covers a location
     * @param needle The location to find.
     * @param haystack the statement map or function map to search in.
     * @returns The index of the smallest statement surrounding the location, or null if not found.
     */
    private findMatchingStatementInMap(needle, haystack);
    private findCoverageCollectionForTest(testId);
    private isCoveragePerTestResult(coverage);
}
