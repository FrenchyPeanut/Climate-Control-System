"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("stryker-api/core");
var istanbul_lib_instrument_1 = require("istanbul-lib-instrument");
var objectUtils_1 = require("../utils/objectUtils");
var log4js_1 = require("log4js");
var COVERAGE_CURRENT_TEST_VARIABLE_NAME = '__strykerCoverageCurrentTest__';
var CoverageInstrumenterTranspiler = /** @class */ (function () {
    function CoverageInstrumenterTranspiler(settings, testFramework) {
        this.settings = settings;
        this.testFramework = testFramework;
        this.fileCoverageMaps = Object.create(null);
        this.instrumenter = istanbul_lib_instrument_1.createInstrumenter({ coverageVariable: this.coverageVariable, preserveComments: true });
        this.log = log4js_1.getLogger(CoverageInstrumenterTranspiler.name);
    }
    CoverageInstrumenterTranspiler.prototype.transpile = function (files) {
        var _this = this;
        try {
            var result = {
                outputFiles: files.map(function (file) { return _this.instrumentFileIfNeeded(file); }),
                error: null
            };
            return Promise.resolve(this.addCollectCoverageFileIfNeeded(result));
        }
        catch (error) {
            return Promise.resolve(this.errorResult(objectUtils_1.errorToString(error)));
        }
    };
    Object.defineProperty(CoverageInstrumenterTranspiler.prototype, "coverageVariable", {
        /**
         * Coverage variable *must* have the name '__coverage__'. Only that variable
         * is reported back to the TestRunner process when using one of the karma
         * test framework adapters (karma-jasmine, karma-mocha, ...).
         *
         * However, when coverageAnalysis is 'perTest' we don't choose that variable name right away,
         * because we need that variable to hold all coverage results per test. Instead, we use __strykerCoverageCurrentTest__
         * and after each test copy over the value of that current test to the global coverage object __coverage__
         */
        get: function () {
            switch (this.settings.config.coverageAnalysis) {
                case 'perTest':
                    return COVERAGE_CURRENT_TEST_VARIABLE_NAME;
                default:
                    return '__coverage__';
            }
        },
        enumerable: true,
        configurable: true
    });
    CoverageInstrumenterTranspiler.prototype.patchRanges = function (fileCoverage) {
        function patchRange(range) {
            // Lines from istanbul are one-based, lines in Stryker are 0-based
            range.end.line--;
            range.start.line--;
        }
        Object.keys(fileCoverage.statementMap).forEach(function (key) { return patchRange(fileCoverage.statementMap[key]); });
        Object.keys(fileCoverage.branchMap).forEach(function (key) {
            patchRange(fileCoverage.branchMap[key].loc);
            fileCoverage.branchMap[key].locations.forEach(patchRange);
            fileCoverage.branchMap[key].line--;
        });
        Object.keys(fileCoverage.fnMap).forEach(function (key) {
            patchRange(fileCoverage.fnMap[key].loc);
            patchRange(fileCoverage.fnMap[key].decl);
            fileCoverage.fnMap[key].line--;
        });
        return fileCoverage;
    };
    CoverageInstrumenterTranspiler.prototype.instrumentFileIfNeeded = function (file) {
        if (this.settings.config.coverageAnalysis !== 'off' && file.kind === core_1.FileKind.Text && file.mutated) {
            return this.instrumentFile(file);
        }
        else {
            return file;
        }
    };
    CoverageInstrumenterTranspiler.prototype.instrumentFile = function (sourceFile) {
        try {
            var content = this.instrumenter.instrumentSync(sourceFile.content, sourceFile.name);
            var fileCoverage = this.patchRanges(this.instrumenter.lastFileCoverage());
            this.fileCoverageMaps[sourceFile.name] = this.retrieveCoverageMaps(fileCoverage);
            return {
                mutated: sourceFile.mutated,
                included: sourceFile.included,
                name: sourceFile.name,
                transpiled: sourceFile.transpiled,
                kind: core_1.FileKind.Text,
                content: content
            };
        }
        catch (error) {
            throw new Error("Could not instrument \"" + sourceFile.name + "\" for code coverage. " + objectUtils_1.errorToString(error));
        }
    };
    CoverageInstrumenterTranspiler.prototype.retrieveCoverageMaps = function (input) {
        var output = {
            statementMap: input.statementMap,
            fnMap: {}
        };
        Object.keys(input.fnMap).forEach(function (key) { return output.fnMap[key] = input.fnMap[key].loc; });
        return output;
    };
    CoverageInstrumenterTranspiler.prototype.addCollectCoverageFileIfNeeded = function (result) {
        if (Object.keys(this.fileCoverageMaps).length && this.settings.config.coverageAnalysis === 'perTest') {
            if (this.testFramework) {
                // Add piece of javascript to collect coverage per test results
                var content = this.coveragePerTestFileContent(this.testFramework);
                var fileName = '____collectCoveragePerTest____.js';
                result.outputFiles.unshift({
                    kind: core_1.FileKind.Text,
                    name: fileName,
                    included: true,
                    transpiled: false,
                    mutated: false,
                    content: content
                });
                this.log.debug("Adding test hooks file for coverageAnalysis \"perTest\": " + fileName);
            }
            else {
                return this.errorResult('Cannot measure coverage results per test, there is no testFramework and thus no way of executing code right before and after each test.');
            }
        }
        return result;
    };
    CoverageInstrumenterTranspiler.prototype.coveragePerTestFileContent = function (testFramework) {
        return objectUtils_1.wrapInClosure("\n          var id = 0, globalCoverage, coverageResult;\n          window.__coverage__ = globalCoverage = { deviations: {} };\n          " + testFramework.beforeEach(beforeEachFragmentPerTest) + "\n          " + testFramework.afterEach(afterEachFragmentPerTest) + "\n          " + cloneFunctionFragment + ";\n      ");
    };
    CoverageInstrumenterTranspiler.prototype.errorResult = function (error) {
        return {
            error: error,
            outputFiles: []
        };
    };
    return CoverageInstrumenterTranspiler;
}());
exports.default = CoverageInstrumenterTranspiler;
var cloneFunctionFragment = "    \nfunction clone(source) {\n    var result = source;\n    if (Array.isArray(source)) {\n        result = [];\n        source.forEach(function (child, index) {\n            result[index] = clone(child);\n        });\n    } else if (typeof source == \"object\") {\n        result = {};\n        for (var i in source) {\n            result[i] = clone(source[i]);\n        }\n    }\n    return result;\n}";
var beforeEachFragmentPerTest = "\nif (!globalCoverage.baseline && window." + COVERAGE_CURRENT_TEST_VARIABLE_NAME + ") {\nglobalCoverage.baseline = clone(window." + COVERAGE_CURRENT_TEST_VARIABLE_NAME + ");\n}";
var afterEachFragmentPerTest = "\nglobalCoverage.deviations[id] = coverageResult = {};\nid++;\nvar coveragePerFile = window." + COVERAGE_CURRENT_TEST_VARIABLE_NAME + ";\nif(coveragePerFile) {\nObject.keys(coveragePerFile).forEach(function (file) {\n    var coverage = coveragePerFile[file];\n    var baseline = globalCoverage.baseline[file];\n    var fileResult = { s: {}, f: {} };\n    var touchedFile = false;\n    for(var i in coverage.s){\n      if(coverage.s[i] !== baseline.s[i]){\n        fileResult.s[i] = coverage.s[i];\n        touchedFile = true;\n      }\n    }\n    for(var i in coverage.f){\n      if(coverage.f[i] !== baseline.f[i]){\n        fileResult.f[i] = coverage.f[i];\n        touchedFile = true;\n      }\n    }\n    if(touchedFile){\n      coverageResult[file] = fileResult;\n    }\n});\n}";
//# sourceMappingURL=CoverageInstrumenterTranspiler.js.map